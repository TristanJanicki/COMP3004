// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/runtime"

	models "github.com/COMP3004/UserAccounts/pkg/gen/models"
)

// SignInCreatedCode is the HTTP code returned for type SignInCreated
const SignInCreatedCode int = 201

/*SignInCreated OK

swagger:response signInCreated
*/
type SignInCreated struct {

	/*
	  In: Body
	*/
	Payload *models.TokenResponse `json:"body,omitempty"`
}

// NewSignInCreated creates SignInCreated with default headers values
func NewSignInCreated() *SignInCreated {

	return &SignInCreated{}
}

// WithPayload adds the payload to the sign in created response
func (o *SignInCreated) WithPayload(payload *models.TokenResponse) *SignInCreated {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the sign in created response
func (o *SignInCreated) SetPayload(payload *models.TokenResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *SignInCreated) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(201)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// SignInTemporaryRedirectCode is the HTTP code returned for type SignInTemporaryRedirect
const SignInTemporaryRedirectCode int = 307

/*SignInTemporaryRedirect Authentication challenge required

swagger:response signInTemporaryRedirect
*/
type SignInTemporaryRedirect struct {

	/*
	  In: Body
	*/
	Payload *models.AuthChallengeRequiredResult `json:"body,omitempty"`
}

// NewSignInTemporaryRedirect creates SignInTemporaryRedirect with default headers values
func NewSignInTemporaryRedirect() *SignInTemporaryRedirect {

	return &SignInTemporaryRedirect{}
}

// WithPayload adds the payload to the sign in temporary redirect response
func (o *SignInTemporaryRedirect) WithPayload(payload *models.AuthChallengeRequiredResult) *SignInTemporaryRedirect {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the sign in temporary redirect response
func (o *SignInTemporaryRedirect) SetPayload(payload *models.AuthChallengeRequiredResult) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *SignInTemporaryRedirect) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(307)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// SignInUnauthorizedCode is the HTTP code returned for type SignInUnauthorized
const SignInUnauthorizedCode int = 401

/*SignInUnauthorized Incorrect username or password

swagger:response signInUnauthorized
*/
type SignInUnauthorized struct {

	/*
	  In: Body
	*/
	Payload *models.NotAllowedResponse `json:"body,omitempty"`
}

// NewSignInUnauthorized creates SignInUnauthorized with default headers values
func NewSignInUnauthorized() *SignInUnauthorized {

	return &SignInUnauthorized{}
}

// WithPayload adds the payload to the sign in unauthorized response
func (o *SignInUnauthorized) WithPayload(payload *models.NotAllowedResponse) *SignInUnauthorized {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the sign in unauthorized response
func (o *SignInUnauthorized) SetPayload(payload *models.NotAllowedResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *SignInUnauthorized) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(401)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// SignInNotFoundCode is the HTTP code returned for type SignInNotFound
const SignInNotFoundCode int = 404

/*SignInNotFound Not found

swagger:response signInNotFound
*/
type SignInNotFound struct {

	/*
	  In: Body
	*/
	Payload *models.NotFoundResponse `json:"body,omitempty"`
}

// NewSignInNotFound creates SignInNotFound with default headers values
func NewSignInNotFound() *SignInNotFound {

	return &SignInNotFound{}
}

// WithPayload adds the payload to the sign in not found response
func (o *SignInNotFound) WithPayload(payload *models.NotFoundResponse) *SignInNotFound {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the sign in not found response
func (o *SignInNotFound) SetPayload(payload *models.NotFoundResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *SignInNotFound) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(404)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}

// SignInInternalServerErrorCode is the HTTP code returned for type SignInInternalServerError
const SignInInternalServerErrorCode int = 500

/*SignInInternalServerError Internal error

swagger:response signInInternalServerError
*/
type SignInInternalServerError struct {

	/*
	  In: Body
	*/
	Payload *models.ErrorResponse `json:"body,omitempty"`
}

// NewSignInInternalServerError creates SignInInternalServerError with default headers values
func NewSignInInternalServerError() *SignInInternalServerError {

	return &SignInInternalServerError{}
}

// WithPayload adds the payload to the sign in internal server error response
func (o *SignInInternalServerError) WithPayload(payload *models.ErrorResponse) *SignInInternalServerError {
	o.Payload = payload
	return o
}

// SetPayload sets the payload to the sign in internal server error response
func (o *SignInInternalServerError) SetPayload(payload *models.ErrorResponse) {
	o.Payload = payload
}

// WriteResponse to the client
func (o *SignInInternalServerError) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {

	rw.WriteHeader(500)
	if o.Payload != nil {
		payload := o.Payload
		if err := producer.Produce(rw, payload); err != nil {
			panic(err) // let the recovery middleware deal with this
		}
	}
}
